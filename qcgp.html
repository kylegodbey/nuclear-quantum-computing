
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Final challenge: Solving the Gross-Pitaevskii Equation &#8212; Quantum Computing Applications in Nuclear Physics</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Contributors" href="contributors.html" />
    <link rel="prev" title="Reduced Basis Method on a Quantum Computer" href="horbm/quantum.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Quantum Computing Applications in Nuclear Physics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="landing.html">
                    Quantum Computing Applications in Nuclear Physics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="introduction/introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="vqe/vqe.html">
   Variational Quantum Eigensolver
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="vqe/deuteron.html">
     Quantum Computing the Deuteron
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
    <label for="toctree-checkbox-2">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="vqe/n2.html">
       First Steps: N=2
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vqe/n3.html">
       Complexity++: N=3
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vqe/general.html">
       A General Case
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="vqe/qng.html">
     Quantum Natural Gradient
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="hardware/hardware.html">
   Running on “Hardware”
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="hardware/noise.html">
     Noisy Circuits
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="hardware/error.html">
     Error Mitigation: Zero-Noise Extrapolation
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="hardware/zne.html">
       Zero-Noise Extrapolation: the N=2 case
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="hardware/ibm.html">
     Real Hardware
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="horbm/horbm.html">
   Dimensionality Reduction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="horbm/classical.html">
     Quantum Harmonic Oscillator as a two level system
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="horbm/quantum.html">
     Reduced Basis Method on a Quantum Computer
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Final challenge: Solving the Gross-Pitaevskii Equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="contributors.html">
   Contributors
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/kylegodbey/nuclear-quantum-computing/main?urlpath=tree/nuclear-qc/qcgp.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        <a href="https://colab.research.google.com/github/kylegodbey/nuclear-quantum-computing/blob/main/nuclear-qc/qcgp.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Colab"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_colab.png">
  </span>
<span class="headerbtn__text-container">Colab</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/kylegodbey/nuclear-quantum-computing"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/kylegodbey/nuclear-quantum-computing/issues/new?title=Issue%20on%20page%20%2Fqcgp.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/qcgp.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#background">
   Background
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#creating-an-orthonormal-basis-of-two-elements-and-checking-that-our-problem-is-well-behaved-fast-decay-in-singular-values">
   Creating an orthonormal basis of two elements and checking that our problem is well behaved (fast decay in singular values)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#we-will-now-model-an-effective-hamiltonian-in-which-two-particles-interact-each-one-represents-one-of-these-two-components">
   We will now model an effective hamiltonian in which two “particles” interact, each one represents one of these two components.
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Final challenge: Solving the Gross-Pitaevskii Equation</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#background">
   Background
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#creating-an-orthonormal-basis-of-two-elements-and-checking-that-our-problem-is-well-behaved-fast-decay-in-singular-values">
   Creating an orthonormal basis of two elements and checking that our problem is well behaved (fast decay in singular values)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#we-will-now-model-an-effective-hamiltonian-in-which-two-particles-interact-each-one-represents-one-of-these-two-components">
   We will now model an effective hamiltonian in which two “particles” interact, each one represents one of these two components.
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="final-challenge-solving-the-gross-pitaevskii-equation">
<h1>Final challenge: Solving the Gross-Pitaevskii Equation<a class="headerlink" href="#final-challenge-solving-the-gross-pitaevskii-equation" title="Permalink to this headline">#</a></h1>
<p>Parts adapted from https://arxiv.org/pdf/2203.05284.pdf with permission from the authors.</p>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">#</a></h2>
<p>The <a class="reference external" href="https://link.springer.com/article/10.1007/BF02731494">Gross</a>-<a class="reference external" href="http://jetp.ras.ru/cgi-bin/dn/e_013_02_0451.pdf">Pitaevskii</a> (GP) equation (also <a class="reference external" href="https://epubs.siam.org/doi/10.1137/20M1313106">here</a> for a RBM application) is a nonlinear Schrödinger equation that approximately describes the low-energy properties of dilute Bose-Einstein condensates. Using a self-consistent mean field approximation, the many-body wavefunction is reduced to a description in terms of a single complex-valued wavefunction <span class="math notranslate nohighlight">\(\phi(\vec{r})\)</span>. We work with the <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.62.063610">one-dimensional Gross-Pitaevskii equation</a> with a harmonic trapping potential by letting <span class="math notranslate nohighlight">\(F_\alpha\)</span> be:</p>
<div class="amsmath math notranslate nohighlight" id="equation-921414c6-d636-4863-af94-f7abd427ad19">
<span class="eqno">(16)<a class="headerlink" href="#equation-921414c6-d636-4863-af94-f7abd427ad19" title="Permalink to this equation">#</a></span>\[\begin{equation}
  F_{q,\kappa}(\phi)= -\phi''+\kappa x^2\phi+q|\phi|^2\phi-\lambda_{q,\kappa}\phi=0,
\end{equation}\]</div>
<p>where the parameters are now <span class="math notranslate nohighlight">\(\alpha=\{\kappa, q\}\)</span>, which are proportional to the strength of the harmonic trapping and the self-coupling of the wavefunction,respectively, while <span class="math notranslate nohighlight">\(\lambda_{q,\kappa}\)</span> is proportional to the ground state energ. <span class="math notranslate nohighlight">\(\phi(x)\)</span> is a single variable function that depends on <span class="math notranslate nohighlight">\(x\)</span> and it is normalized to unity.</p>
<p>To be able to solve this problem in a quantum computer with few qbits we follow the same procedure as with the Harmonic Oscillator problem and cast the equations in the reduced basis. We once again expand our solution in a basis of <span class="math notranslate nohighlight">\(n\)</span> elements:</p>
<div class="amsmath math notranslate nohighlight" id="equation-11a4d257-0cbd-4129-8092-aaf4480def8e">
<span class="eqno">(17)<a class="headerlink" href="#equation-11a4d257-0cbd-4129-8092-aaf4480def8e" title="Permalink to this equation">#</a></span>\[\begin{align}
\hat{\phi}_{\alpha}(x) = \sum_{i=1}^{n} a_{i} \phi_{i}(x) 
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_{i}(x)\)</span> are informed on previous solutions built on a classical computer to the non-linear Schrodinger equation for chosen values of <span class="math notranslate nohighlight">\(\alpha=\{\kappa,q\}\)</span>.</p>
<p>The main challenge now resides in the fact that we can’t write <span class="math notranslate nohighlight">\(F_{\alpha}\)</span> in terms of linear operators since the “Hamiltonian” is dependent on the actual solution <span class="math notranslate nohighlight">\(\phi(x)\)</span>: <span class="math notranslate nohighlight">\(H_\alpha \equiv H_\alpha[\phi]=(-\frac{d^2}{dx^2}+\kappa x^2 +q|\phi|^2)\)</span>. The Galerkin projection equations are general enough that this problem can be <a class="reference external" href="https://arxiv.org/pdf/2203.05284.pdf">tackled directly</a>, which leads to a series of non-linear equations (up to fourth powers) in the unknown coefficients <span class="math notranslate nohighlight">\(a_i\)</span> and the approximated eigenvalue <span class="math notranslate nohighlight">\(\hat\lambda\)</span>.</p>
<p>In order to tackle this problem in a quantum circuit with the machinery we have developed up to this point we propose an approach that allows one to avoid having to solve a non-linear problem by instead solving a linear one many times in an iteratively scheme. This is the approach frequently used in many Density Functional Theory implementations [CITE]. We make a guess, which we call <span class="math notranslate nohighlight">\(\phi_0\)</span>, on the solution of the original non-linear problem. We now iteratively find the solution <span class="math notranslate nohighlight">\(\phi_{n}\)</span> to a linear Schrodinger equation with Hamiltonian <span class="math notranslate nohighlight">\(H_\alpha[\phi_{n-1}]\)</span>. If the original guess <span class="math notranslate nohighlight">\(\phi_0\)</span> was close enough to the true solution, then with enough iterations we should reach self consistency and obtain a wave function such that <span class="math notranslate nohighlight">\(F_\alpha [\phi]= H_\alpha[\phi]\phi -\lambda \phi=0\)</span>.</p>
<p>In the following we implement this iterative approach to solve the GP equation first in a classical computer, using a basis with two states. We then proceed to design solution for a quantum computer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sci</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.operators.second_quantization</span> <span class="kn">import</span> <span class="n">FermionicOp</span>
<span class="kn">from</span> <span class="nn">qiskit_nature.mappers.second_quantization</span> <span class="kn">import</span> <span class="n">JordanWignerMapper</span><span class="p">,</span> <span class="n">ParityMapper</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### NOTE: hbar = 1 in this demo</span>

<span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">kappa</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    1-d harmonic Oscillator potential</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or nd array</span>
<span class="sd">        position.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        oscillator length parameter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        value of potential evaluated at x.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">kappa</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>


 

<span class="k">def</span> <span class="nf">construct_H</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">mass</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">PHIgrid</span><span class="p">):</span>
   <span class="c1">#PHIgrid is the value of the guess for the nonlinear part at each location</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">off_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">off_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">sci</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">toeplitz</span><span class="p">(</span><span class="n">off_diag</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">mass</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">kappa</span><span class="p">))</span><span class="o">+</span> <span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">PHIgrid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">H</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#First define global variables</span>
<span class="n">h</span> <span class="o">=</span>  <span class="mi">1</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">### grid spacing for domain (Warning around 10**(-3) it starts to get slow).</span>
<span class="c1">### HO global parameters </span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># principle quantum number to solve in HO</span>
<span class="n">mass</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># mass for the HO system</span>
<span class="c1"># define the domain boundaries</span>
<span class="n">x_a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="c1"># left boundary </span>
<span class="n">x_b</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># right boundary </span>
<span class="n">x_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span><span class="n">x_b</span><span class="o">+</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_array</span><span class="p">)</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of grid points: &#39;</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H : 2d ndarray</span>
<span class="sd">        Hamiltonian Matrix.</span>
<span class="sd">    grid : ndarray</span>
<span class="sd">        Discretized 1d domain.</span>
<span class="sd">    h : float</span>
<span class="sd">        grid spacing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    evals : ndarray</span>
<span class="sd">        returns nd array of eigenvalues of H. </span>
<span class="sd">    evects : ndarray</span>
<span class="sd">        returns ndarray of eigenvectors of H.</span>
<span class="sd">    Eigenvalues and eigenvectors are ordered in ascending order. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">evals</span><span class="p">,</span><span class="n">evects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">evects</span> <span class="o">=</span> <span class="n">evects</span><span class="o">.</span><span class="n">T</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">evect</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">evects</span><span class="p">):</span>
        <span class="c1">#norm = np.sqrt(1/sci.integrate.simpson(evect*evect,grid))</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">evect</span><span class="p">))</span>  <span class="c1">#We need to check these normalizations in the other jupyter book!</span>
        <span class="n">evects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">evects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">norm</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">evals</span><span class="p">,</span><span class="n">evects</span>


<span class="k">def</span> <span class="nf">IterativeSolver</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">maxIterations</span><span class="p">):</span>
    <span class="n">Hn</span> <span class="o">=</span> <span class="n">construct_H</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_array</span><span class="p">)))</span> <span class="c1"># First Hamiltonian with the q interaction put to zero</span>
    <span class="n">PHIn</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">Hn</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">h</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ListOfPhiOlds</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">IJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxIterations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">IJ</span><span class="o">&lt;</span><span class="n">maxIterations</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">qeff</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="p">(</span><span class="n">IJ</span><span class="o">/</span><span class="n">maxIterations</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qeff</span><span class="o">=</span><span class="n">q</span>
        <span class="n">Hn</span><span class="o">=</span><span class="n">construct_H</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">qeff</span><span class="p">,(</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
        <span class="n">SOL</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">Hn</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        
        <span class="n">PHIn</span><span class="o">=</span><span class="n">SOL</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ListOfPhiOlds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PHIn</span><span class="p">))</span>
        
        
            
    <span class="c1"># print(&quot;max iterations:&quot; ,IJ) </span>
    <span class="c1"># return ListOfPhiOlds</span>
    <span class="k">return</span> <span class="n">SOL</span>
    
    




<span class="k">def</span> <span class="nf">getSystem</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi_array</span><span class="p">,</span><span class="n">phi_array</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sets up syetem of equations for Galerkin projection &lt;\phi_{j},F_{k}(phi_{k})&gt;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        Hamiltonian matrix.</span>
<span class="sd">    psi_array : ndarray</span>
<span class="sd">        array of projector functions. Assumes rows are corresponding to discretized functions</span>
<span class="sd">    phi_array : TYPE</span>
<span class="sd">        DESCRIPTION.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Function</span>
<span class="sd">        Function that takes in a vector of parameters of the form (a_{1},a_{2},....,\lambda_{\alpha}) </span>
<span class="sd">        and outputs of the system of equations. \lambda_{\alpha} is the eigenvalue of HO equation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">## </span>
    <span class="k">def</span> <span class="nf">system</span><span class="p">(</span><span class="n">a_vec</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a_vec : ndarray</span>
<span class="sd">            vector of parameters (a_{k},\lambda).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : ndarray</span>
<span class="sd">            outputs of the Galerkin projection equations and normalization functions &lt;\hat{\phi}|\hat{\phi}&gt; = 1.</span>
<span class="sd">            This systems can be solved using sci.optimize.fsolve or using your choice of method.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_vec</span><span class="p">))</span>
        <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># from normalization</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a_vec</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a_vec</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a_vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">phi_array</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">-</span> \
                <span class="n">a_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">a_vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">phi_array</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a_vec</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a_vec</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a_vec</span><span class="p">[</span><span class="n">kp</span><span class="p">]</span><span class="o">*</span><span class="n">a_vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_array</span><span class="p">[</span><span class="n">kp</span><span class="p">],</span><span class="n">phi_array</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span>
    <span class="k">return</span> <span class="n">system</span>

    
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of grid points:  201
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># #First define global variables</span>
<span class="c1"># h = 5*10**(-2) ### grid spacing for domain (Warning around 10**(-3) it starts to get slow).</span>
<span class="c1"># ### HO global parameters </span>
<span class="c1"># n = 0 # principle quantum number to solve in HO</span>
<span class="c1"># mass = 1.0 # mass for the HO system</span>
<span class="c1"># # define the domain boundaries</span>
<span class="c1"># x_a = -10 # left boundary </span>
<span class="c1"># x_b = 10 # right boundary </span>
<span class="c1"># x_array = np.arange(x_a,x_b+h,h)</span>
<span class="c1"># m = len(x_array) </span>
<span class="c1"># print(&#39;Number of grid points: &#39;,m)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solution0</span><span class="o">=</span><span class="n">IterativeSolver</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">solution</span><span class="o">=</span><span class="n">IterativeSolver</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span> <span class="n">solution0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;q=0, kappa=1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;q=10, kappa=1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyboardInterrupt</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">ipykernel_2595</span><span class="o">/</span><span class="mf">4130808931.</span><span class="n">py</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="n">solution0</span><span class="o">=</span><span class="n">IterativeSolver</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">solution</span><span class="o">=</span><span class="n">IterativeSolver</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> 
<span class="g g-Whitespace">      </span><span class="mi">4</span> 
<span class="g g-Whitespace">      </span><span class="mi">5</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span> <span class="n">solution0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;q=0, kappa=1&#39;</span><span class="p">)</span>

<span class="nn">/tmp/ipykernel_2595/3314993183.py</span> in <span class="ni">IterativeSolver</span><span class="nt">(grid, q, kappa, maxIterations)</span>
<span class="g g-Whitespace">     </span><span class="mi">50</span>         <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">51</span>             <span class="n">qeff</span><span class="o">=</span><span class="n">q</span>
<span class="ne">---&gt; </span><span class="mi">52</span>         <span class="n">Hn</span><span class="o">=</span><span class="n">construct_H</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">qeff</span><span class="p">,(</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">53</span>         <span class="n">SOL</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">Hn</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">54</span> 

<span class="nn">/tmp/ipykernel_2595/3229265265.py</span> in <span class="ni">construct_H</span><span class="nt">(grid, mass, kappa, q, PHIgrid)</span>
<span class="g g-Whitespace">     </span><span class="mi">28</span>     <span class="n">off_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">29</span>     <span class="n">off_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="ne">---&gt; </span><span class="mi">30</span>     <span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">sci</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">toeplitz</span><span class="p">(</span><span class="n">off_diag</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">mass</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">kappa</span><span class="p">))</span><span class="o">+</span> <span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">PHIgrid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">31</span> 
<span class="g g-Whitespace">     </span><span class="mi">32</span>     <span class="k">return</span> <span class="n">H</span>

<span class="nn">/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/pennylane/numpy/tensor.py</span> in <span class="ni">__array_ufunc__</span><span class="nt">(self, ufunc, method, *inputs, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">153</span>         <span class="c1"># call the ndarray.__array_ufunc__ method to compute the result</span>
<span class="g g-Whitespace">    </span><span class="mi">154</span>         <span class="c1"># of the vectorized ufunc</span>
<span class="ne">--&gt; </span><span class="mi">155</span>         <span class="n">res</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">156</span> 
<span class="g g-Whitespace">    </span><span class="mi">157</span>         <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

<span class="ne">KeyboardInterrupt</span>: 
</pre></div>
</div>
</div>
</div>
<p>First select a set of values of <span class="math notranslate nohighlight">\(\alpha\)</span> to solve the SE with. These solutions will be used as the basis in the reduced basis model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select alpha values to use to solve SE exactly.</span>
<span class="n">alpha_vals</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1">#[q,kappa] Here, we choose 5 values of alpha to solve exactly. This results in 3 basis functions</span>
<span class="c1"># initialize solution arrays. T is the matrix that will hold wavefunction solutions. </span>
<span class="c1"># T has the form T[i][j], i = alpha, j = solution components</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha_vals</span><span class="p">),</span><span class="n">m</span><span class="p">))</span> 
<span class="c1"># T_evals holds the eigenvalues for each evect in T. </span>
<span class="n">T_evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha_vals</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">alpha_sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alpha_vals</span><span class="p">):</span>
    
    <span class="n">evals</span><span class="p">,</span> <span class="n">evects</span> <span class="o">=</span> <span class="n">IterativeSolver</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">alpha_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha_sample</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">700</span><span class="p">)</span> <span class="c1"># solve the system for evals and evects.</span>
    <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">evects</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">evects</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="c1"># assign the nth evect to solution array T</span>
    <span class="n">T_evals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1"># assign the nth eigenvalue to the eigenvalue array T_eval.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha = </span><span class="si">{</span><span class="n">alpha_sample</span><span class="si">}</span><span class="s1">, lambda = </span><span class="si">{</span><span class="n">evals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    

    

<span class="c1"># Make plots of the numerical wavefunction </span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha_vals</span><span class="p">)):</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\alpha$ = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">alpha_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Numerical solutions&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>alpha = [0, 1], lambda = 0.9993746086404902
alpha = [1, 1], lambda = 1.3830689347075433
alpha = [0, 2], lambda = 1.4129624545775548
alpha = [5, 1], lambda = 2.689659524551058
alpha = [10, 1], lambda = 4.022841278511264
</pre></div>
</div>
<img alt="_images/qcgp_8_1.png" src="_images/qcgp_8_1.png" />
</div>
</div>
</section>
<section id="creating-an-orthonormal-basis-of-two-elements-and-checking-that-our-problem-is-well-behaved-fast-decay-in-singular-values">
<h2>Creating an orthonormal basis of two elements and checking that our problem is well behaved (fast decay in singular values)<a class="headerlink" href="#creating-an-orthonormal-basis-of-two-elements-and-checking-that-our-problem-is-well-behaved-fast-decay-in-singular-values" title="Permalink to this headline">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">phi1</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="n">Vh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#multiplying by -1 so they are positive at x=0, not necessary but the plots look better</span>
<span class="n">phi2</span><span class="o">=</span><span class="mi">1</span><span class="o">*</span><span class="n">Vh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">n_comps</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># number of principle components to plot (i.e number of column vectors of SVD matrix V to plot)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">s</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;o-&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Singular values of solution matrix $T$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\sigma$&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">phi1</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">phi2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;First </span><span class="si">{</span><span class="n">n_comps</span><span class="si">}</span><span class="s1"> principle components&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/qcgp_10_0.png" src="_images/qcgp_10_0.png" />
</div>
</div>
</section>
<section id="we-will-now-model-an-effective-hamiltonian-in-which-two-particles-interact-each-one-represents-one-of-these-two-components">
<h2>We will now model an effective hamiltonian in which two “particles” interact, each one represents one of these two components.<a class="headerlink" href="#we-will-now-model-an-effective-hamiltonian-in-which-two-particles-interact-each-one-represents-one-of-these-two-components" title="Permalink to this headline">#</a></h2>
<p>This discussion retraces everything we did before for the Harmonic Oscillator. The main difference is that now the Hamiltonian effectively depends on the solution <span class="math notranslate nohighlight">\(H_\alpha \equiv H_\alpha[\phi]\)</span>, but since we are aiming at solving the problem iteratively, at each stage we have a fixed linear Hamiltonian.</p>
<p>Here we explicitly construct <span class="math notranslate nohighlight">\( \hat{\phi}_{\alpha}= a_{1} \phi_{1}+a_2\phi_2\)</span> and use the Galerkin method, that is, projecting <span class="math notranslate nohighlight">\(F_{\alpha}\big( \hat{\phi}_{\alpha}(x) \big)\)</span> over <span class="math notranslate nohighlight">\(2\)</span> linearly independent functions projecting functions <span class="math notranslate nohighlight">\(\{ \psi_{i}\}_{i=1}^{2}\)</span>.</p>
<div class="amsmath math notranslate nohighlight" id="equation-53d1106a-cf9d-4425-b9b3-dca68520c769">
<span class="eqno">(18)<a class="headerlink" href="#equation-53d1106a-cf9d-4425-b9b3-dca68520c769" title="Permalink to this equation">#</a></span>\[\begin{align}
&amp;\langle \psi{1}| F_{\alpha}\big( \hat{\phi}_{\alpha}(x) \big) \rangle = 0 \\
&amp;\langle \psi{2}| F_{\alpha}\big( \hat{\phi}_{\alpha}(x) \big) \rangle = 0 
\end{align}\]</div>
<p>We can interpret this as enforcing the orthogonality of <span class="math notranslate nohighlight">\(F_{\alpha}\big( \hat{\phi}_{\alpha}(x) \big)\)</span> to the subspace spanned by <span class="math notranslate nohighlight">\(\{\psi_{i}\}\)</span> that is, by finding <span class="math notranslate nohighlight">\(\hat{\phi}_{\alpha}\)</span> such that <span class="math notranslate nohighlight">\(F_{\alpha}(\hat{\phi}_{\alpha})\)</span> is approximately zero up to the ability of the set <span class="math notranslate nohighlight">\(\{\psi_{i}\}\)</span>. The choice of projecting functions <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span> is arbitrary, but here we choose the solution set <span class="math notranslate nohighlight">\(\{ \phi_{i} \}\)</span> to be our projecting functions to make our lives easier. Since <span class="math notranslate nohighlight">\(\lambda\)</span> is also unknown, we need an additional equation. This comes from the normalization conditions:</p>
<div class="amsmath math notranslate nohighlight" id="equation-e1ab9e3b-5f05-4a69-a490-2a4872823ffa">
<span class="eqno">(19)<a class="headerlink" href="#equation-e1ab9e3b-5f05-4a69-a490-2a4872823ffa" title="Permalink to this equation">#</a></span>\[\begin{align}
\langle \hat{\phi}_{\alpha_{k}}|\hat{\phi}_{\alpha_{k}} \rangle  = 1
\end{align}\]</div>
<p>We can re-write the projecting equations taking advantage of the linear form of <span class="math notranslate nohighlight">\(F_\alpha\)</span> to obtain an effective 2-level system Hamiltonian. We note that:</p>
<div class="amsmath math notranslate nohighlight" id="equation-49ba94c6-39a2-4a6e-9d57-dd72085d114a">
<span class="eqno">(20)<a class="headerlink" href="#equation-49ba94c6-39a2-4a6e-9d57-dd72085d114a" title="Permalink to this equation">#</a></span>\[\begin{align}
&amp;\langle \phi_{i}| F_{\alpha}\big( \hat{\phi}_{\alpha}(x) \big) \rangle =  \\
&amp;\langle \phi_{i}|  a_1 H_\alpha \phi_1 + a_2 H_\alpha \phi_2 - a_1\hat \lambda \phi_1 - a_2\hat \lambda \phi_2\rangle
\end{align}\]</div>
<p>Since <span class="math notranslate nohighlight">\(\langle \phi_i|\phi_j\rangle = \delta _{i,j}\)</span>, we arrive at the following matrix equation for the projecting equations:</p>
<div class="amsmath math notranslate nohighlight" id="equation-b30c2ce8-20ef-494a-9748-b7a7f9a716a3">
<span class="eqno">(21)<a class="headerlink" href="#equation-b30c2ce8-20ef-494a-9748-b7a7f9a716a3" title="Permalink to this equation">#</a></span>\[\begin{equation}
\tilde H_\alpha |a\rangle = \hat\lambda |a\rangle
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(|a\rangle = \{a_1,a_2\}\)</span> and</p>
<div class="amsmath math notranslate nohighlight" id="equation-0a02eca8-2afc-463a-b0a6-6a1a8b31ab11">
<span class="eqno">(22)<a class="headerlink" href="#equation-0a02eca8-2afc-463a-b0a6-6a1a8b31ab11" title="Permalink to this equation">#</a></span>\[\begin{equation}
\tilde H_\alpha = \begin{bmatrix} \langle \phi_1|H_\alpha|\phi_1\rangle &amp; \langle \phi_1|H_\alpha|\phi_2\rangle \\ \langle \phi_2|H_\alpha|\phi_1\rangle &amp; \langle \phi_2|H_\alpha|\phi_2\rangle \end{bmatrix}
\end{equation}\]</div>
<p>while the normalization condition translates into:</p>
<div class="amsmath math notranslate nohighlight" id="equation-49875a42-d662-41e0-8e32-1d0c3476b96b">
<span class="eqno">(23)<a class="headerlink" href="#equation-49875a42-d662-41e0-8e32-1d0c3476b96b" title="Permalink to this equation">#</a></span>\[\begin{equation}
\langle a|a \rangle  = a_1^2+a_2^2= 1
\end{equation}\]</div>
<p>Now we proceed to construct this Hamiltonian matrix for our problem at hand. We note that although <span class="math notranslate nohighlight">\(\tilde H_\alpha\)</span> depennds on <span class="math notranslate nohighlight">\(\alpha\)</span>, the dependance is only in the tow potential parts and it is affine (linear): <span class="math notranslate nohighlight">\(H_\alpha=H_0+\kappa H_1 +q H_2\)</span>, where <span class="math notranslate nohighlight">\(H_0= - \frac{d^{2}}{dx^{2}}\)</span>, <span class="math notranslate nohighlight">\(H_1= x^2\)</span>, and <span class="math notranslate nohighlight">\(H_2=|\phi(x)|^2\)</span>. We then decompose <span class="math notranslate nohighlight">\(\tilde H_\alpha= \tilde H_0 + \kappa \tilde H_1+ q \tilde H_2\)</span>. We now construct these matrices, <span class="math notranslate nohighlight">\(H_2\)</span> being a function that must be constructed every time:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dim0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_array</span><span class="p">)</span>
<span class="n">off_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim0</span><span class="p">)</span>
<span class="n">off_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">H0</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sci</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">toeplitz</span><span class="p">(</span><span class="n">off_diag</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">mass</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 
<span class="n">H1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">tildeH0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
<span class="n">tildeH1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>

<span class="n">tildeH0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>
<span class="n">tildeH0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>

<span class="n">tildeH1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>
<span class="n">tildeH1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>

<span class="n">H2_11</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">phi1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H2_12</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">phi1</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span>
<span class="n">H2_22</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">phi2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">tildeH2_11</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
<span class="n">tildeH2_11</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_11</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH2_11</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_11</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>
<span class="n">tildeH2_11</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_11</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH2_11</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_11</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>




<span class="n">tildeH2_12</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
<span class="n">tildeH2_12</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_12</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH2_12</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_12</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>
<span class="n">tildeH2_12</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_12</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH2_12</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_12</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>


<span class="n">tildeH2_22</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
<span class="n">tildeH2_22</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_22</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH2_22</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_22</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>
<span class="n">tildeH2_22</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_22</span><span class="p">,</span><span class="n">phi1</span><span class="p">))</span>
<span class="n">tildeH2_22</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H2_22</span><span class="p">,</span><span class="n">phi2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tildeH2</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
    <span class="c1"># H2=np.diag(PHIList**2)</span>
    
    
    <span class="c1"># tildeH2=np.array([[0.0,0.0],[0.0,0.0]])</span>

    <span class="c1"># tildeH2[0][0]=np.dot(phi1,np.dot(H2,phi1))</span>
    <span class="c1"># tildeH2[0][1]=np.dot(phi1,np.dot(H2,phi2))</span>
    <span class="c1"># tildeH2[1][0]=np.dot(phi2,np.dot(H2,phi1))</span>
    <span class="c1"># tildeH2[1][1]=np.dot(phi2,np.dot(H2,phi2))</span>
    <span class="c1"># return tildeH2</span>


    <span class="k">return</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tildeH2_11</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">tildeH2_12</span><span class="o">+</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tildeH2_22</span><span class="p">)</span><span class="o">/</span><span class="n">h</span>
    



<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;H0=&#39;</span><span class="p">,</span> <span class="n">tildeH0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;H1=&#39;</span><span class="p">,</span><span class="n">tildeH1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;H2=&#39;</span><span class="p">,</span><span class="n">tildeH2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>H0= [[ 0.42023097 -0.58365092]
 [-0.58365092  2.61560759]]
H1= [[0.59436083 0.82835933]
 [0.82835933 2.3627665 ]]
H2= [[ 0.36584365 -0.13715205]
 [-0.13715205  0.16958109]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tildeH</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tildeH0</span><span class="o">+</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">tildeH1</span><span class="o">+</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">tildeH2</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">systemSolver</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">):</span>
    <span class="n">resultssystem</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">tildeH</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">))</span>
    <span class="c1"># if resultssystem[1][0][0]&lt;0:</span>
    <span class="c1">#     resultssystem[1][0]=resultssystem[1][0]*(-1)</span>
    <span class="c1"># if resultssystem[1][1][0]&lt;0:</span>
    <span class="c1">#     resultssystem[1][1]=resultssystem[1][1]*(-1)   </span>
    <span class="k">return</span> <span class="p">[</span><span class="n">resultssystem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">resultssystem</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

<span class="k">def</span> <span class="nf">phibuilderFromCoeffs</span><span class="p">(</span><span class="n">coefficients</span><span class="p">):</span>
    <span class="n">coefficients0</span><span class="o">=</span><span class="p">[</span><span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coefficients</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">h</span><span class="p">),</span><span class="n">coefficients</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coefficients</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">coefficients0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">phi1</span><span class="o">+</span><span class="n">coefficients0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">phi2</span>

<span class="k">def</span> <span class="nf">ItetariveRBMsolver</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">maxIterations</span><span class="p">):</span>
    <span class="n">sol0</span><span class="o">=</span><span class="n">systemSolver</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># sol0=systemSolver([alpha[0],alpha[1]],[0.9913,0.131144])</span>
    
    <span class="n">ListOfPhiOlds</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">for</span> <span class="n">IJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxIterations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">IJ</span><span class="o">&lt;</span><span class="n">maxIterations</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1"># if IJ&lt;0:</span>
            <span class="n">qeff</span><span class="o">=</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">IJ</span><span class="o">/</span><span class="n">maxIterations</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qeff</span><span class="o">=</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">sol0</span><span class="o">=</span><span class="n">systemSolver</span><span class="p">([</span><span class="n">qeff</span><span class="p">,</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>  
        <span class="p">(</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="n">ListOfPhiOlds</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span><span class="o">/</span><span class="mf">6.0</span>
        <span class="p">)</span>


        <span class="n">ListOfPhiOlds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sol0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">sol0</span>
</pre></div>
</div>
</div>
</div>
<p>Now we try our solution solver against the finite element computation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now we can construct our RBM for an alpha of our choosing. </span>
<span class="n">alpha_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">solFinite</span><span class="o">=</span><span class="n">IterativeSolver</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">alpha_k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha_k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1000</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">solFull</span><span class="o">=</span><span class="n">ItetariveRBMsolver</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">solGaler</span><span class="o">=</span><span class="n">phibuilderFromCoeffs</span><span class="p">(</span><span class="n">solFull</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="n">lamGaler</span><span class="o">=</span><span class="n">solFull</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


    

<span class="c1"># Make plots of the numerical wavefunction </span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>


<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">solFinite</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;Finite element method $\alpha$ = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="o">-</span><span class="n">solGaler</span><span class="p">,</span><span class="n">label</span><span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Galerkin $\alpha$ = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Numerical solutions&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/qcgp_16_0.png" src="_images/qcgp_16_0.png" />
</div>
</div>
<p>Now that we’ve laid the groundwork for getting RBM solutions for this nonlinear problem, we can explore how to get it running in the quantum paradigm. The next cell will contain a lot of setup without much explanation, so it’s recommended that you check back in the VQE, noise, and RBM sections for individual explanations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pauli_token_to_operator</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
    <span class="n">qubit_terms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)):</span>
        <span class="c1"># Special case of identity</span>
        <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#pauli, qubit_idx = term, term</span>
            <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                <span class="n">qubit_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">term</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                <span class="n">qubit_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">term</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                <span class="n">qubit_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">term</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid input.&quot;</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">qubit_terms</span><span class="o">==</span><span class="p">[]):</span>
            <span class="n">qubit_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">Identity</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">full_term</span> <span class="o">=</span> <span class="n">qubit_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">qubit_terms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">full_term</span> <span class="o">=</span> <span class="n">full_term</span> <span class="o">@</span> <span class="n">term</span>

    <span class="k">return</span> <span class="n">full_term</span>


<span class="k">def</span> <span class="nf">parse_hamiltonian_input</span><span class="p">(</span><span class="n">input_data</span><span class="p">):</span>
    <span class="c1"># Get the input</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pauli_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">input_data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Go through line by line and build up the Hamiltonian</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="c1">#line = line.strip()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="c1"># Parse coefficients</span>
        <span class="n">sign</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="c1"># Parse Pauli component</span>
        <span class="n">pauli</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        
        <span class="n">pauli_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_token_to_operator</span><span class="p">(</span><span class="n">pauli</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">pauli_terms</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ham</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">mat_ele</span><span class="p">,</span><span class="n">mapper</span><span class="o">=</span><span class="n">JordanWignerMapper</span><span class="p">):</span>
    <span class="c1"># Start out by zeroing what will be our fermionic operator</span>
    <span class="n">op</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="c1"># Construct the terms of the Hamiltonian in terms of creation/annihilation operators </span>
            <span class="n">op</span> <span class="o">+=</span>  <span class="nb">float</span><span class="p">(</span><span class="n">mat_ele</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> \
            <span class="n">FermionicOp</span><span class="p">([([(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">),(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">)],</span> <span class="mf">1.0</span><span class="p">)])</span>

    <span class="n">hamstr</span> <span class="o">=</span> <span class="s2">&quot;+ &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mapper</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">second_q_op</span><span class="o">=</span><span class="n">op</span><span class="p">))</span>

    <span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">parse_hamiltonian_input</span><span class="p">(</span><span class="n">hamstr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hamiltonian</span> 
</pre></div>
</div>
</div>
</div>
<p>We’ll define functions to help with running VQE since we will likely need to do it a few times.</p>
<p><code class="docutils literal notranslate"><span class="pre">update_ham</span></code> will return an updated hamiltonian given basis coefficients and the alpha vector</p>
<p><code class="docutils literal notranslate"><span class="pre">run_vqe_fixed</span></code> will run the VQE algorithm for a fixed hamiltonian defined by input coefficients</p>
<p><code class="docutils literal notranslate"><span class="pre">run_vqe</span></code> performs VQE with a dynamically updating Hamiltonian during the gradient descent. This algorithm decreases the total number of iterations required for convergence at the cost of additional measurements per step – but it tends towards being much more efficient.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update_ham</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">):</span>
    <span class="c1"># Define dimension</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="c1"># Define Hamiltonian</span>
    <span class="n">mat_ele</span> <span class="o">=</span> <span class="n">tildeH</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">ham</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">mat_ele</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span>

<span class="k">def</span> <span class="nf">run_vqe_fixed</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">init_params</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">conv_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">update_ham</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="n">cost_fn</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">ExpvalCost</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
    
    <span class="n">opt</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">GradientDescentOptimizer</span><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="n">step_size</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">init_params</span>

    <span class="n">gd_param_history</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span>
    <span class="n">gd_cost_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="c1"># Take a step in parameter space and record your energy</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">prev_energy</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">step_and_cost</span><span class="p">(</span><span class="n">cost_fn</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="c1"># This keeps track of our energy for plotting at comparisons</span>
        <span class="n">gd_param_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">gd_cost_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_energy</span><span class="p">)</span>

        <span class="c1"># Here we see what the energy of our system is with the new parameters</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">cost_fn</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Calculate difference between new and old energies</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">prev_energy</span><span class="p">)</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;It = </span><span class="si">{:}</span><span class="s2">,  Energy = </span><span class="si">{:.8f}</span><span class="s2">,  Conv = {&quot;</span>
                <span class="s2">&quot;:.8f}, Time Elapsed = </span><span class="si">{:.3f}</span><span class="s2"> s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


        <span class="k">if</span> <span class="n">conv</span> <span class="o">&lt;=</span> <span class="n">conv_tol</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final value of the energy = </span><span class="si">{:.8f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">energy</span><span class="p">))</span>
    <span class="k">if</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of iterations = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">run_vqe</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">init_params</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">mixing</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">conv_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">update_ham</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="n">cost_fn</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">ExpvalCost</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
    
    <span class="n">opt</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">GradientDescentOptimizer</span><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="n">step_size</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">init_params</span>

    <span class="n">probs</span> <span class="o">=</span> <span class="n">prob_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">new_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">gd_param_history</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span>
    <span class="n">gd_cost_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="mf">10.0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="c1"># Take a step in parameter space and record your energy</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">prev_energy</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">step_and_cost</span><span class="p">(</span><span class="n">cost_fn</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">prev_energy</span> <span class="o">=</span> <span class="n">energy</span>
        <span class="c1"># This keeps track of our energy for plotting at comparisons</span>
        <span class="n">gd_param_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">gd_cost_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_energy</span><span class="p">)</span>

        <span class="c1"># Here we see what the energy of our system is with the new parameters</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">cost_fn</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Calculate difference between new and old energies</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">prev_energy</span><span class="p">)</span>

        <span class="c1"># Update hamiltonian with new coeffs</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">prob_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">new_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">mixing</span><span class="p">)</span><span class="o">*</span><span class="n">coeffs</span> <span class="o">+</span> <span class="n">mixing</span><span class="o">*</span><span class="n">new_coeffs</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">update_ham</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

        <span class="n">cost_fn</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">ExpvalCost</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;It = </span><span class="si">{:}</span><span class="s2">,  Energy = </span><span class="si">{:.8f}</span><span class="s2">,  Conv = {&quot;</span>
                <span class="s2">&quot;:.8f}, Time Elapsed = </span><span class="si">{:.3f}</span><span class="s2"> s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


        <span class="k">if</span> <span class="n">conv</span> <span class="o">&lt;=</span> <span class="n">conv_tol</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final value of the energy = </span><span class="si">{:.8f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">energy</span><span class="p">))</span>
    <span class="k">if</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of iterations = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">n</span>
</pre></div>
</div>
</div>
</div>
<p>Up next is setting up our circuits! This is exactly from the <a class="reference internal" href="horbm/quantum.html"><span class="doc std std-doc">Quantum Computing RBM</span></a> example since we’re not concerning ourselves with noise just yet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the order you&#39;d like to go to</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Setup the device. Here we&#39;ll use the default qubit just to get it working</span>
<span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>

<span class="c1"># Define a general ansatz for arbitrary numbers of dimensions</span>

<span class="n">particles</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">ref_state</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">qchem</span><span class="o">.</span><span class="n">hf_state</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

<span class="n">ansatz</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">ParticleConservingU2</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="n">ref_state</span><span class="p">)</span>

<span class="n">layers</span> <span class="o">=</span> <span class="n">dim</span>

<span class="c1"># generate the prob function</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">prob_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">ansatz</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">dev</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">dev</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now let’s see what happens when running VQE for only the first element in the basis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">qml</span><span class="o">.</span><span class="n">ParticleConservingU2</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n_layers</span><span class="o">=</span><span class="n">layers</span><span class="p">,</span> <span class="n">n_wires</span><span class="o">=</span><span class="n">dim</span><span class="p">))</span>

<span class="n">update_ham</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="n">classical</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">tildeH</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result expected from classical computation: &quot;</span><span class="p">,</span> <span class="n">classical</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="n">params</span><span class="p">,</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">run_vqe</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">init_params</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Result expected from classical computation:  3.3910483648941208
Final value of the energy = 3.39105632
</pre></div>
</div>
</div>
</div>
<p>Awesome! With our basis coefficients set to <code class="docutils literal notranslate"><span class="pre">[1,0]</span></code>, we get the same result as we expect from before. Now comes the fun part of iteratively solving the problem! There are two approaches we could take:</p>
<ul class="simple">
<li><p>“Standard” Iterative VQE | This method is the simplest conceptually and closely tracks the methods used to iteratively solve the problem on classical systems - namely you use the VQE to solve the optimal parameters for a fixed initial Hamiltonian, then you compute the coefficients of the basis and do it again. Between VQE runs you can mix the coefficients to ensure convergence, but ultimately you will obtain the optimal parameters and coefficients for the problem.</p></li>
<li><p>“Dynamic” VQE | This method performs a measurement to determine the coefficients every step within the VQE algorithm and dynamically updates the Hamiltonian. This leads to faster convergence for this nonlinear problem and fewer steps overall.</p></li>
</ul>
<p>We have implemented both methods in the notebook, and show both in the following cells. Feel free to play around with the parameters that tune the VQE algorithm and see what the effects are!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
<span class="n">classical</span><span class="o">=</span><span class="n">ItetariveRBMsolver</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">sol_params</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">run_vqe_fixed</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">init_params</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>
<span class="n">probs</span> <span class="o">=</span> <span class="n">prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">)</span>
<span class="n">new_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">new_coeffs</span>
<span class="k">if</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients: &quot;</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

<span class="n">mixing</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">total_it</span> <span class="o">=</span> <span class="n">n</span>
<span class="n">prev_energy</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">mixing</span><span class="p">)</span><span class="o">*</span><span class="n">coeffs</span> <span class="o">+</span> <span class="n">mixing</span><span class="o">*</span><span class="n">new_coeffs</span>
    <span class="n">sol_params</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">run_vqe_fixed</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,</span><span class="n">coeffs</span><span class="p">,</span><span class="n">sol_params</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>
    <span class="n">total_it</span> <span class="o">+=</span> <span class="n">n</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">energy</span><span class="o">-</span><span class="n">prev_energy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Convergence tolerance met!&quot;</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="n">prev_energy</span> <span class="o">=</span> <span class="n">energy</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">)</span>
    <span class="n">new_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients: &quot;</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result expected from classical computation: &quot;</span><span class="p">,</span> <span class="n">classical</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients expected from classical computation: &quot;</span><span class="p">,</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result from standard VQE: &quot;</span><span class="p">,</span><span class="n">energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients from standard VQE: &quot;</span><span class="p">,</span><span class="n">new_coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">new_coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Iterations Required: &quot;</span><span class="p">,</span> <span class="n">total_it</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Convergence tolerance met!
Result expected from classical computation:  3.2502202855515776
Coefficients expected from classical computation:  0.9913354984896009 0.131354213614845
Result from standard VQE:  3.2502193236644996
Coefficients from standard VQE:  0.9913354774404971 0.13135437247317416
Total Iterations Required:  60
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sol_params</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">run_vqe</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">init_params</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>

<span class="n">probs</span> <span class="o">=</span> <span class="n">prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">)</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result expected from classical computation: &quot;</span><span class="p">,</span> <span class="n">classical</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients expected from classical computation: &quot;</span><span class="p">,</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result from dynamic VQE: &quot;</span><span class="p">,</span><span class="n">energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients from dynamic VQE: &quot;</span><span class="p">,</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Iterations Required: &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Result expected from classical computation:  3.2502202855515776
Coefficients expected from classical computation:  0.9913354984896009 0.131354213614845
Result from dynamic VQE:  3.2502207938475203
Coefficients from dynamic VQE:  0.9913354781979928 0.13135436675633222
Total Iterations Required:  22
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solGaler</span><span class="o">=</span><span class="n">phibuilderFromCoeffs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
<span class="n">lamGaler</span><span class="o">=</span><span class="n">solFull</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Make plots of the numerical wavefunction </span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">solFinite</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;Finite element method $\alpha$ = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">solGaler</span><span class="p">,</span><span class="n">label</span><span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Quantum Computing Galerkin $\alpha$ = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Numerical solutions&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/qcgp_28_0.png" src="_images/qcgp_28_0.png" />
</div>
</div>
<p>They both perform really well, but the dynamic VQE requires less messy code to get it running, so that’s what we’ll use next! What we’ll do now is add some noise to our circuit and see how that affects our performance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#define some noise model to use in pennylane from qiskit.test.mock</span>
<span class="kn">from</span> <span class="nn">qiskit.test.mock</span> <span class="kn">import</span> <span class="n">FakeLima</span>
<span class="kn">from</span> <span class="nn">qiskit.providers.aer.noise</span> <span class="kn">import</span> <span class="n">NoiseModel</span>

<span class="n">backend</span> <span class="o">=</span> <span class="n">FakeLima</span><span class="p">()</span>
<span class="n">noise_model</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="o">.</span><span class="n">from_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>

<span class="c1">#set up noisy device</span>
<span class="n">dev_sim</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;qiskit.aer&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="n">sol_params</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">run_vqe</span><span class="p">(</span><span class="n">alpha_k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">init_params</span><span class="p">,</span><span class="n">dev_sim</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">probs</span> <span class="o">=</span> <span class="n">prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">)</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result expected from classical computation: &quot;</span><span class="p">,</span> <span class="n">classical</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients expected from classical computation: &quot;</span><span class="p">,</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result from dynamic VQE: &quot;</span><span class="p">,</span><span class="n">energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients from dynamic VQE: &quot;</span><span class="p">,</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Iterations Required: &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>It = 0,  Energy = 3.45008765,  Conv = 6.54991235, Time Elapsed = 5.546 s
It = 1,  Energy = 3.31128987,  Conv = 0.13879778, Time Elapsed = 5.924 s
It = 2,  Energy = 3.30066910,  Conv = 0.01062077, Time Elapsed = 5.757 s
It = 3,  Energy = 3.24861704,  Conv = 0.05205207, Time Elapsed = 6.105 s
It = 4,  Energy = 3.27428866,  Conv = 0.02567163, Time Elapsed = 6.819 s
It = 5,  Energy = 3.24819814,  Conv = 0.02609053, Time Elapsed = 5.804 s
It = 6,  Energy = 3.25508899,  Conv = 0.00689085, Time Elapsed = 6.656 s
It = 7,  Energy = 3.27100412,  Conv = 0.01591514, Time Elapsed = 5.780 s
It = 8,  Energy = 3.31753318,  Conv = 0.04652906, Time Elapsed = 5.710 s
It = 9,  Energy = 3.25481757,  Conv = 0.06271561, Time Elapsed = 7.099 s
It = 10,  Energy = 3.31092820,  Conv = 0.05611064, Time Elapsed = 5.798 s
It = 11,  Energy = 3.30897420,  Conv = 0.00195401, Time Elapsed = 6.549 s
It = 12,  Energy = 3.29723379,  Conv = 0.01174041, Time Elapsed = 5.490 s
It = 13,  Energy = 3.28860444,  Conv = 0.00862934, Time Elapsed = 5.853 s
It = 14,  Energy = 3.28756224,  Conv = 0.00104220, Time Elapsed = 6.863 s
It = 15,  Energy = 3.32841700,  Conv = 0.04085476, Time Elapsed = 6.156 s
It = 16,  Energy = 3.30915667,  Conv = 0.01926033, Time Elapsed = 6.297 s
It = 17,  Energy = 3.28407537,  Conv = 0.02508130, Time Elapsed = 5.904 s
It = 18,  Energy = 3.32175444,  Conv = 0.03767908, Time Elapsed = 5.810 s
It = 19,  Energy = 3.27801711,  Conv = 0.04373733, Time Elapsed = 6.692 s
It = 20,  Energy = 3.32350278,  Conv = 0.04548567, Time Elapsed = 6.494 s
It = 21,  Energy = 3.30055953,  Conv = 0.02294325, Time Elapsed = 5.930 s
It = 22,  Energy = 3.30920933,  Conv = 0.00864980, Time Elapsed = 5.796 s
It = 23,  Energy = 3.28905023,  Conv = 0.02015910, Time Elapsed = 5.652 s
It = 24,  Energy = 3.26975919,  Conv = 0.01929104, Time Elapsed = 6.092 s
It = 25,  Energy = 3.29094021,  Conv = 0.02118102, Time Elapsed = 6.526 s
It = 26,  Energy = 3.30211557,  Conv = 0.01117536, Time Elapsed = 5.687 s
It = 27,  Energy = 3.32210400,  Conv = 0.01998844, Time Elapsed = 6.284 s
It = 28,  Energy = 3.30324798,  Conv = 0.01885603, Time Elapsed = 5.610 s
It = 29,  Energy = 3.29828116,  Conv = 0.00496681, Time Elapsed = 5.642 s
It = 30,  Energy = 3.29565115,  Conv = 0.00263002, Time Elapsed = 6.956 s
It = 31,  Energy = 3.30187247,  Conv = 0.00622132, Time Elapsed = 5.647 s
It = 32,  Energy = 3.31154264,  Conv = 0.00967017, Time Elapsed = 6.610 s
It = 33,  Energy = 3.30546372,  Conv = 0.00607892, Time Elapsed = 5.404 s
It = 34,  Energy = 3.27940380,  Conv = 0.02605992, Time Elapsed = 5.633 s
It = 35,  Energy = 3.30888528,  Conv = 0.02948148, Time Elapsed = 6.732 s
It = 36,  Energy = 3.27081687,  Conv = 0.03806842, Time Elapsed = 5.855 s
It = 37,  Energy = 3.28225989,  Conv = 0.01144303, Time Elapsed = 6.374 s
It = 38,  Energy = 3.26278061,  Conv = 0.01947929, Time Elapsed = 5.676 s
It = 39,  Energy = 3.28063551,  Conv = 0.01785490, Time Elapsed = 5.738 s
It = 40,  Energy = 3.29267797,  Conv = 0.01204246, Time Elapsed = 6.554 s
It = 41,  Energy = 3.28356477,  Conv = 0.00911321, Time Elapsed = 6.357 s
It = 42,  Energy = 3.34580861,  Conv = 0.06224384, Time Elapsed = 5.969 s
It = 43,  Energy = 3.31229907,  Conv = 0.03350954, Time Elapsed = 6.162 s
It = 44,  Energy = 3.24888997,  Conv = 0.06340910, Time Elapsed = 5.773 s
It = 45,  Energy = 3.32192019,  Conv = 0.07303022, Time Elapsed = 6.016 s
It = 46,  Energy = 3.32720467,  Conv = 0.00528449, Time Elapsed = 6.782 s
It = 47,  Energy = 3.29778082,  Conv = 0.02942386, Time Elapsed = 5.630 s
It = 48,  Energy = 3.32401439,  Conv = 0.02623357, Time Elapsed = 6.197 s
It = 49,  Energy = 3.27325533,  Conv = 0.05075905, Time Elapsed = 5.806 s
Final value of the energy = 3.27325533
Number of iterations =  49
Result expected from classical computation:  3.2502202855515776
Coefficients expected from classical computation:  0.9913354984896009 0.131354213614845
Result from dynamic VQE:  3.273255334766314
Coefficients from dynamic VQE:  0.9921464969052414 0.12508128828349135
Total Iterations Required:  49
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mitiq</span> <span class="k">as</span> <span class="nn">mq</span>
<span class="kn">from</span> <span class="nn">mitiq.zne.scaling</span> <span class="kn">import</span> <span class="n">fold_global</span>
<span class="kn">from</span> <span class="nn">mitiq.zne.inference</span> <span class="kn">import</span> <span class="n">RichardsonFactory</span>
<span class="kn">from</span> <span class="nn">pennylane.transforms</span> <span class="kn">import</span> <span class="n">mitigate_with_zne</span>

<span class="c1"># generate the prob function</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev_sim</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">noisy_prob_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">wire</span><span class="p">):</span>
    <span class="n">ansatz</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">dev_sim</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">wire</span><span class="p">)</span>

<span class="n">probs</span> <span class="o">=</span> <span class="n">noisy_prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result expected from classical computation: &quot;</span><span class="p">,</span> <span class="n">classical</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients expected from classical computation: &quot;</span><span class="p">,</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">classical</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result from dynamic VQE: &quot;</span><span class="p">,</span><span class="n">energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficients from dynamic VQE: &quot;</span><span class="p">,</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Iterations Required: &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">207</span><span class="o">-</span><span class="mi">044</span><span class="n">f1213c12f</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">     </span><span class="mi">10</span>     <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">wire</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span> 
<span class="ne">---&gt; </span><span class="mi">12</span> <span class="n">probs</span> <span class="o">=</span> <span class="n">noisy_prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="g g-Whitespace">     </span><span class="mi">13</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="g g-Whitespace">     </span><span class="mi">14</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result expected from classical computation: &quot;</span><span class="p">,</span> <span class="n">classical</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="nn">~/.local/lib/python3.8/site-packages/pennylane/qnode.py</span> in <span class="ni">__call__</span><span class="nt">(self, *args, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">607</span> 
<span class="g g-Whitespace">    </span><span class="mi">608</span>         <span class="c1"># construct the tape</span>
<span class="ne">--&gt; </span><span class="mi">609</span>         <span class="bp">self</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">610</span> 
<span class="g g-Whitespace">    </span><span class="mi">611</span>         <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cache&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="nn">~/.local/lib/python3.8/site-packages/pennylane/qnode.py</span> in <span class="ni">construct</span><span class="nt">(self, args, kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">524</span> 
<span class="g g-Whitespace">    </span><span class="mi">525</span>         <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">526</span>             <span class="bp">self</span><span class="o">.</span><span class="n">_qfunc_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">527</span>         <span class="bp">self</span><span class="o">.</span><span class="n">_tape</span><span class="o">.</span><span class="n">_qfunc_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qfunc_output</span>
<span class="g g-Whitespace">    </span><span class="mi">528</span> 

<span class="nn">&lt;ipython-input-207-044f1213c12f&gt;</span> in <span class="ni">noisy_prob_circuit</span><span class="nt">(params, wire)</span>
<span class="g g-Whitespace">      </span><span class="mi">8</span> <span class="k">def</span> <span class="nf">noisy_prob_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">wire</span><span class="p">):</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span>     <span class="n">ansatz</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">dev_sim</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">10</span>     <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">wire</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span> 
<span class="g g-Whitespace">     </span><span class="mi">12</span> <span class="n">probs</span> <span class="o">=</span> <span class="n">noisy_prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="ne">TypeError</span>: &#39;MeasurementProcess&#39; object is not subscriptable
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#set up the extrapolation step and scale factors to use</span>
<span class="n">extrapolate</span> <span class="o">=</span> <span class="n">RichardsonFactory</span><span class="o">.</span><span class="n">extrapolate</span>
<span class="n">scale_factors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">noisy_prob_circuit</span><span class="p">(</span><span class="n">sol_params</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">sim_qnode</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">QNode</span><span class="p">(</span><span class="n">noisy_prob_circuit</span><span class="p">,</span> <span class="n">dev_sim</span><span class="p">)</span>

<span class="c1">#use ZNE to mitigate error</span>
<span class="n">mitigated_qnode</span> <span class="o">=</span> <span class="n">mitigate_with_zne</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">fold_global</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)(</span><span class="n">sim_qnode</span><span class="p">)</span>
<span class="n">zne_result</span> <span class="o">=</span> <span class="n">mitigated_qnode</span><span class="p">(</span><span class="n">sol_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.0926 0.9074]
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">206</span><span class="o">-</span><span class="mi">6</span><span class="n">b11519877b7</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span> <span class="c1">#use ZNE to mitigate error</span>
<span class="g g-Whitespace">     </span><span class="mi">10</span> <span class="n">mitigated_qnode</span> <span class="o">=</span> <span class="n">mitigate_with_zne</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">fold_global</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)(</span><span class="n">sim_qnode</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">11</span> <span class="n">zne_result</span> <span class="o">=</span> <span class="n">mitigated_qnode</span><span class="p">(</span><span class="n">sol_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">14</span><span class="p">)</span>

<span class="nn">~/.local/lib/python3.8/site-packages/pennylane/transforms/batch_transform.py</span> in <span class="ni">_wrapper</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">311</span>             <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">312</span> 
<span class="ne">--&gt; </span><span class="mi">313</span>             <span class="k">return</span> <span class="n">processing_fn</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">314</span> 
<span class="g g-Whitespace">    </span><span class="mi">315</span>         <span class="k">return</span> <span class="n">_wrapper</span>

<span class="nn">~/.local/lib/python3.8/site-packages/pennylane/transforms/mitigate.py</span> in <span class="ni">processing_fn</span><span class="nt">(results)</span>
<span class="g g-Whitespace">    </span><span class="mi">222</span>         <span class="p">]</span>  <span class="c1"># creates nested list according to reps_per_factor</span>
<span class="g g-Whitespace">    </span><span class="mi">223</span>         <span class="n">results</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="ne">--&gt; </span><span class="mi">224</span>         <span class="n">extrapolated</span> <span class="o">=</span> <span class="n">extrapolate</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="o">**</span><span class="n">extrapolate_kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">225</span>         <span class="k">return</span> <span class="n">extrapolated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">extrapolated</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="k">else</span> <span class="n">extrapolated</span>
<span class="g g-Whitespace">    </span><span class="mi">226</span> 

<span class="nn">~/.local/lib/python3.8/site-packages/mitiq/zne/inference.py</span> in <span class="ni">extrapolate</span><span class="nt">(scale_factors, exp_values, full_output)</span>
<span class="g g-Whitespace">    </span><span class="mi">932</span>         <span class="c1"># with order equal to the number of data points minus 1.</span>
<span class="g g-Whitespace">    </span><span class="mi">933</span>         <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_factors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="ne">--&gt; </span><span class="mi">934</span>         <span class="k">return</span> <span class="n">PolyFactory</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">935</span>             <span class="n">scale_factors</span><span class="p">,</span> <span class="n">exp_values</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">full_output</span>
<span class="g g-Whitespace">    </span><span class="mi">936</span>         <span class="p">)</span>

<span class="nn">~/.local/lib/python3.8/site-packages/mitiq/zne/inference.py</span> in <span class="ni">extrapolate</span><span class="nt">(scale_factors, exp_values, order, full_output)</span>
<span class="g g-Whitespace">    </span><span class="mi">860</span>         <span class="s2">&quot;&quot;&quot;</span>
<span class="g g-Whitespace">    </span><span class="mi">861</span><span class="s2"> </span>
<span class="ne">--&gt; </span><span class="mi">862</span><span class="s2">         opt_params, params_cov = mitiq_polyfit(</span>
<span class="g g-Whitespace">    </span><span class="mi">863</span><span class="s2">             scale_factors, exp_values, order</span>
<span class="g g-Whitespace">    </span><span class="mi">864</span><span class="s2">         )</span>

<span class="nn">~/.local/lib/python3.8/site-packages/mitiq/zne/inference.py</span> in <span class="ni">mitiq_polyfit</span><span class="nt">(scale_factors, exp_values, deg, weights)</span>
<span class="g g-Whitespace">    </span><span class="mi">185</span><span class="s2">     with warnings.catch_warnings(record=True) as warn_list:</span>
<span class="g g-Whitespace">    </span><span class="mi">186</span><span class="s2">         try:</span>
<span class="ne">--&gt; </span><span class="mi">187</span><span class="s2">             opt_params, params_cov = np.polyfit(</span>
<span class="g g-Whitespace">    </span><span class="mi">188</span><span class="s2">                 scale_factors, exp_values, deg, w=weights, cov=True</span>
<span class="g g-Whitespace">    </span><span class="mi">189</span><span class="s2">             )</span>

<span class="nn">&lt;__array_function__ internals&gt;</span> in <span class="ni">polyfit</span><span class="nt">(*args, **kwargs)</span>

<span class="nn">~/.local/lib/python3.8/site-packages/numpy/lib/polynomial.py</span> in <span class="ni">polyfit</span><span class="nt">(x, y, deg, rcond, full, w, cov)</span>
<span class="g g-Whitespace">    </span><span class="mi">630</span><span class="s2">         raise TypeError(&quot;expected non-empty vector for x&quot;)</span>
<span class="g g-Whitespace">    </span><span class="mi">631</span><span class="s2">     if y.ndim &lt; 1 or y.ndim &gt; 2:</span>
<span class="ne">--&gt; </span><span class="mi">632</span><span class="s2">         raise TypeError(&quot;expected 1D or 2D array for y&quot;)</span>
<span class="g g-Whitespace">    </span><span class="mi">633</span><span class="s2">     if x.shape[0] != y.shape[0]:</span>
<span class="g g-Whitespace">    </span><span class="mi">634</span><span class="s2">         raise TypeError(&quot;expected x and y to have same length&quot;)</span>

<span class="ne">TypeError</span>: expected 1D or 2D array for y
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="horbm/quantum.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Reduced Basis Method on a Quantum Computer</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="contributors.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Contributors</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Jingyi Li, Alexandra Semposki, Pablo Giuliani, Kyle Godbey<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>